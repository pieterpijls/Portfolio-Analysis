---
title: 'Statistics for Finance and Insurance Assignment 2: Portfolio Analysis'
author: Pieter Pijls^[r0387948 (Faculty of Economics and Business, KU Leuven, Leuven,
  Belgium)]
date: "Academic year 2017-2018"
output:
  html_document:
  word_document: default
  pdf_document:
    fig_height: 5
    fig_width: 12
    latex_engine: xelatex
    fig_caption: yes
    includes:  
      in_header: preamble-latex.tex
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H')
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r,  include=FALSE}
#Set seed an clear memory
rm(list=ls())
set.seed(0387948)
```

```{r,  include=FALSE}
#Load packages
packages <- c("copula","mgcv", "fCopulae", "Ecdat", "fGarch", "MASS", "tidyverse", "ggthemes","plotly","ggplot2","xtable","knitr","statmod", "actuar", "fitdistrplus", "PerformanceAnalytics", "gridExtra", "grid", "scales", "quadprog","quantmod","plyr","reshape","kableExtra","xts","float","lubridate","PortfolioAnalytics")

# This function will load package or if not already installed install it
suppressMessages(packages <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x)
    library(x, character.only = TRUE)
  }
}))
```

```{r,  include=FALSE}
# Load data
load("~/Documents/KU LEUVEN/MFAE/STATISTICS FOR FINANCE&INSURANCE/Assignment 2 Portfolio Analysis/data_returns_387948.RData")
colnames(data)<-c("HON","SUN","STW","DRH","AVI","CBL","MER","GPS","MAS","BLC")
data_backup <- data
```

# Introduction

In this assignment different portfolios are constructed with 10 individiual stocks. First, we investigate the stock return data for the period 1999-2016. Next, we construct the minimum variance, tangency and minimum risk contribution portfolio using the first 126 observations. Finally, we investigate the three portfolios with weekly rebalaning and a rolling window of 126 and 63 observations. 

# Data Exploration

We explore the data by investigating the marginal distribution of returns of each stock, and by looking at the inter-dependence of the returns. First, we create 10 QQ-plots to investigate if stocks returns are normally distributed. Figure 1 illustrates that te stock returns are not normally distributed because the obsevartions are not on the linear line. In addition the QQ-plots also illustrates that the distributions of the dail stock returns are heavy tailed and contain some outliers. This can be observerd from the deviations from the linear line which become larger in the more extreme theoretical quantiles.

```{r fig1, echo=FALSE, fig.cap="\\label{fig:fig1}QQ-plots Daily Stock Returns"}
#QQplots
par(mfrow=c(2,5))
for (i in 1:ncol(data))
{
  qqnorm(data[,i],main=colnames(data[,i]))
  qqline(data[,i])
}
```

```{r,  include=FALSE}
#data for plot
gdata <- as.data.frame(data)
gdata <- cbind(row.names(gdata),gdata)
gdata  <- melt(gdata,id=c("row.names(gdata)"))
gdata[,1]<-as.Date(gdata[,1])
colnames(gdata) <- c("Date","Equity","Return")
```

Figure 2 shows the daily stock returns from 1999 to 2016. The figure illustrates that stock returns are non-stationary as the variance is not constant over time (e.g. Financial crisis 2008-2009 we observe a high volatility in returns). A stationary process has the property that the mean, variance and autocorrelation structure do not change over time. The stock with ticker MER (blue dots) clearly does not satisfy these properties as the variance is changing over time. Also, the figure shows that the stock returns are positive dependent. They tend to move in group in times of financial stress. 

```{r fig2, echo=FALSE, fig.cap="\\label{fig:fig2}Daily Stock Returns from 1999-2016"}
#daily returns stocks
p<-ggplot(gdata,aes(x=Date,y=Return)) + geom_point(aes(color=Equity),size=0.5) + scale_x_date(expand = c(0, 0),name="Year",labels = date_format("%Y"), breaks=date_breaks("2 years"),limits=c(as.Date(c("1999-01-04","2016-12-30")))) 
p
#ggplotly(p)
```

Next, we investigate the dependence structure by computing the correlations between the different stock returns. As we already observed from the graph the correlation matrix in table 1 shows that stock returns are positively correlated. 

```{r, echo=FALSE}
kable(round(cor(data),2), format = "latex", caption = "Correlation Matrix", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

# Portfolio construction and optimization

In this section we set up the efficient frontier, the tangency portfolio, the minimum variance portfolio and the minimum risk contribution portfolio based on the first 126 returns of each stock. We assume the risk-free rate $i_rf$ is 3% and that risk is measured as standard deviation of the return. Finally, we compare the expected return $\mu$, standard deviation $\sigma$, Sharpe ratio and weights $w$ between the three portfolios. To set up the efficient frontier we need to calculate the covariance matrix $\sum$


```{r,  include=FALSE}
#take first 126 observations
completedata<-data
data<-data[1:126,]
Returns.xts <- xts(data*100,order.by = index(data)) # multiply by 100 !!
```

```{r,  include=FALSE}
# By the numbers
Returnsmean <- apply(Returns.xts,2,mean)
Returnssd <- apply(Returns.xts,2,sd)
Returnsmedian <- apply(Returns.xts,2,mean)
Returnsqn <- apply(Returns.xts,2,qn) #trade off efficiency and robustness 
```

```{r,  include=FALSE}
#summary stats
Returns <- as.data.frame(data)
Returns$Year <- year(index(data))
Returns$Month <- month(index(data))
Returns <- cbind(row.names(as.data.frame(data)),Returns)
colnames(Returns)<-c("Date",colnames(data),"Year","Month")

Monthlysd <- ddply(Returns,.(Year,Month),colwise(sd))
Monthlysd$Date <- strptime(sprintf("%s-%02d-01",Monthlysd$Year,Monthlysd$Month),"%Y-%m-%d")
msdmelt <- melt(Monthlysd[,-(1:2)],id="Date")
colnames(msdmelt)[2:3] <- c("Equity","std_Return")
ggplot(msdmelt) + geom_line(aes_string(x="Date",y="std_Return",color="Equity"),size=1.5) + ggtitle("Monthly Rolling Standard Deviations of Daily Returns of 10 shares") + theme(panel.background = element_rect(fill="#CCCCEE"), legend.key = element_rect(fill="#CCCCEE"))
```

```{r,  include=FALSE}
# Estimate covariance matrix
Returnscov <- cov(Returns.xts)
```


```{r, echo=FALSE}
kable(round(Returnscov,2), format = "latex", caption = "Coviarance Matrix", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

We also have to specify our constraints. We make weights $w$ add up to 100% (full investment constraint), have at least the average return (tartget reward constraint) and no short selling constraint. 

\[ \sum w_i =1, \text{ } i=1,...,10 \]

\[ w_i \ge 0, \text{ } i=1,...,10 \]


```{r ,error=TRUE, include=FALSE}
# No short selling - we add an extra constraint e.g. mutual funds 
Amat <- cbind(rep(1,5), Returnsmean[1:10], diag(1,10),diag(-1,10)) # we reconstruct A matrix

N <- length(Returnsmean) 
Amat <- cbind(rep(1,N), Returnsmean, diag(1,nrow=N), diag(-1,nrow=N)) 

# closure constraint
# diag(1,6) 
nrep <- 1000 # we make 1000 replications
muP <- seq(0.001, 0.06, length=nrep) # nrep targets is a sequence from 0,1% to 6% in 1000 steps
sdP <- rep(0, nrep) # 1000 empty to save standard deviation
weights <- matrix(0, nrow=nrep, ncol=10) # 1000 empty matrices were we will save the weights. 

for (i in 1:nrep)
{
  bvec <- c(1, muP[i], rep(0,N), rep(-1,N)) # constraint vector
  result <- solve.QP(Dmat=2*Returnscov, dvec=rep(0,10), Amat=Amat, bvec=bvec,
                     meq=2)  
  # meq=2: all constraints so far are equality constraints
  sdP[i] <- sqrt(result$value)
  weights[i,] <- result$solution
}
# Crashes, why? 
# Because no short selling constraint limits feasible return within range of indivdual equity returns 
# The return cannot be achieved 
```

```{r,  include=FALSE}
# This will work: because we adjust the returns 
muP <- seq(min(Returnsmean)+0.00001, max(Returnsmean)-0.00001, length=nrep)
sdP <- rep(0, nrep) # 1000 empty to save standard deviation
weights <- matrix(0, nrow=nrep, ncol=10) # 1000 empty matrices were we will save the weights. 

for (i in 1:nrep)
{
  bvec <- c(1, muP[i],rep(0,10), rep(-1,N))  # constraint vector
  result <- solve.QP(Dmat=2*Returnscov[1:10,1:10], dvec=rep(0,10), Amat=Amat, bvec=bvec,
                     meq=2)  
  # meq=2: all constraints so far are equality constraints
  sdP[i] <- sqrt(result$value)
  weights[i,] <- result$solution
}
```

```{r,  include=FALSE}
## Efificient frontier and Minimum Variance Portfolio

plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
# Minumum Variance portfolio
MV <- (sdP == min(sdP)) 
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
# Effective portfolios
EFF <- (muP > muP[MV])
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
weights[MV,]
```

```{r,  include=FALSE}
## Risk free portfolio
mufree <- 0.03 # input value of risk-free interest rate

plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
```

```{r,  include=FALSE}
## Tangency Portfolio
sharpe <- (muP-mufree)/sdP 
TAN <- (sharpe == max(sharpe)) 
weights[TAN,] 
sdpT <- sdP[TAN]
mupT <- muP[TAN]
```

```{r,  include=FALSE}
# Plot 
plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
points(sdP[TAN], muP[TAN], cex=2, pch=16,col='blue') 
lines(c(0,5), mufree+c(0,5)*(muP[TAN]-mufree)/sdP[TAN], lwd=4, lty=1,
      col="blue") 
for (i in 1:ncol(data))
{
  text(Returnssd[i], Returnsmean[i], colnames(data[,i]), cex=1)
}
```

```{r,  include=FALSE}
## Minimum risk contribution portfolio
library(DEoptim)

obj <- function(w) {
      
      if (sum(w)==0) {w <- w + 1e-2}
      
      w <- w/sum(w) #normalizing the weight vector
      
      out <- max(w*(Returnscov%*%w))
      return(out)
}
```

```{r, results="hide", include=FALSE}
# Adjust itermax if it takes too long to compute
itermax = 100
out <- DEoptim(fn=obj, lower=rep(0,10),upper=rep(1,10),DEoptim.control(itermax=itermax,trace=F))
wMinContr <- out$optim$bestmem/sum(out$optim$bestmem)
```

```{r,  include=FALSE}
muPMRC <- wMinContr%*%Returnsmean
sdPMRC <- sqrt(wMinContr%*%Returnscov%*%wMinContr)
```

We computed the the efficient frontier, minimum variance (MV) portfolio, tangency (TAN) portfolio and minimum contribution (MINC) portfolio using quadratic programming (using 100 iterations). Figure 3 illustrates the location of the individual stocks on the "reward-risk space" location. In addition, the efficient frontier, capital market line and the three constructed portfolios are shown. Notice, as we use the no-short selling contraint it is impossible to have an expected return greater than the expected return of HON, the stock with the highest return. In fact, there exists an upper bound on the expected return which is equal to the expected return of HON. 

```{r fig3, echo=FALSE, fig.cap="\\label{fig:fig3} Effcient frontier (red), line (blue) connecting the risk-free asset and tangency portfolio (blue dot), the minimum variance portfolio (red triangle), the minimum risk contribution portfolio (green symbol) and 10 individual stocks"}
# FINAL plot with all portfolios stocks and efficient frontier etc
plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
points(sdP[TAN], muP[TAN], cex=2, pch=16,col='blue') 
points(sdPMRC, muPMRC, cex=3, pch=18,col='green') 
lines(c(0,5), mufree+c(0,5)*(muP[TAN]-mufree)/sdP[TAN], lwd=4, lty=1,
      col="blue") 
for (i in 1:ncol(data))
{
  text(Returnssd[i], Returnsmean[i], colnames(data[,i]), cex=1)
}
```

In Table 3 the expected return $\mu$, standard deviance $\sigma$ and sharpe ratio of the different portfolios are given. The minimum variance portfolio is the one with the smallest standard deviation $\sigma$. This follows from the fact that the MVP portfolio is the portfolio with the lowest standard deviation $\sigma$ on the efficient frontier. The tangency portfolio has the highest expected return $\mu$. The Sharpe ratio is defined as 

\[ \text{Sharpe ratio}  = \frac{\mu-r_f}{\sigma} \]

where $i_rf$ is the risk-free investment equal to 3%. The tangency portfolio is the one with the highest Sharpe ratio. This follows from the fact that the tangency portfolio is the portfolio with the maximum sharpe ratio on the efficient frontier.  

```{r,  include=FALSE}
# summary stats portfolio
dt <- data.frame(matrix(ncol = 3, nrow = 3))
colnames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
rownames(dt) <- c("Expected Return","Standard Deviation","Sharpe Ratio")
MVsharpe <- (muP[MV]-0.03)/sdP[MV]
TANsharpe <- (muP[TAN]-0.03)/sdP[TAN]
MINCsharpe <- (muPMRC-0.03)/sdPMRC
dt[1,] <- c(muP[MV],muP[TAN],muPMRC)
dt[2,] <- c(sdP[MV],sdP[TAN],sdPMRC)
dt[3,] <- c(MVsharpe,TANsharpe,MINCsharpe)
```

```{r, echo=FALSE}
kable(dt, format = "latex", caption = "Summary Statistics Portfolios", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

```{r,  include=FALSE}
# create table for report
dt <- data.frame(matrix(ncol = 10, nrow = 3))
rownames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
colnames(dt) <- c("HON","SUN","STW","DRH","AVI","CBL","MER","GPS","MAS","BLC")
dt[1,] <- round(weights[MV,],2)
dt[2,] <- round(weights[TAN,],2)
dt[3,] <- round(wMinContr,2)
```

In Table 4 the weights $w$ of the different portfolios are given. Notice, the minimum variance portfolio invests in less volatile stock, while the tangency portfolio stock invests in shares with higher expected return $\mu$. The minimum risk contribution portfolio is quite similar to the minimum variance portfolio as it also invest in stocks with a low standard deviation $\sigma$.

```{r, echo=FALSE}
kable(dt, format = "latex", caption = "Portfolios Weights", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

```{r,  include=FALSE}
Returns.xts <- xts(completedata*100,order.by = index(completedata)) # multiply by 100 !!
```

The portfolio weights from the previous section are based on the first 126 returns of each stock. This gives us an estimate of the expected portfolio return $\mu$ for the next day. After 5 trading days (a week) we can compute the realized weekly portfolio returns. We consider the following rebalancing strategy. First, we estimate the weights $w$ of the tangency, the minimum variance and the minimum risk contribution portfolio using the most recent 126 daily returns and rebalance the respective portfolio weights $w$ at the close of every Friday. Notice, when Friday the exchange is not open we will consider Thursday as the rebalancing day. Again, we don't allow short sales and assume that the risk-free rate remains fixed at 3%. 

```{r,  include=FALSE}
# Rebalancing with 126 obs
Returns.xts <- cbind(.indexwday(Returns.xts),Returns.xts)

for (i in 1:(nrow(Returns.xts)-1)) # loop over daily returns
  { 
      if (Returns.xts[i,1]==4 && Returns.xts[i+1,1]==1) # if after thursday monday thursday ad end of the week
      { 
        Returns.xts[i,1]<-5
      } else {}
     
  }

Returns.xts[,1][!Returns.xts[,1]==5] <- FALSE # all weekdays which are not friday are zero
Returns.xts[,1][Returns.xts[,1]==5] <- TRUE # all weekdays which are friday or thursday last day week are one

# Create new column Friday which is equal to one if friday or thursday if friday does not exist
colnames(Returns.xts) <- c("Friday",colnames(Returns.xts[,-1]))
Returns <- as.data.frame(Returns.xts)
```

```{r,  include=FALSE}
#Create empty dataframes for returns and weights of different time periodes. 
MVweights   <-  matrix(0,nrow = nrow(Returns.xts)-126,ncol=ncol(Returns)-1)
TANweights  <-  matrix(0,nrow = nrow(Returns.xts)-126,ncol=ncol(Returns)-1)
MINCweights <-  matrix(0,nrow = nrow(Returns.xts)-126,ncol=ncol(Returns)-1)
MVweights[1,]   <- weights[MV,]
TANweights[1,]  <- weights[TAN,]
MINCweights[1,] <- wMinContr
```

```{r,  include=FALSE}
#### MV and TAN portfolio
for (a in 2:(nrow(Returns.xts)-127))
{
  
  if (Returns[a+125,]$Friday==TRUE) # rebalance portfolio and calculate return
  {
    Returnscov <- cov(Returns.xts[a:(a+126),-1])
    Returnsmean <- apply(Returns.xts[a:(a+126),-1],2,mean)
    muP <- seq(min(Returnsmean)+.00001, max(Returnsmean)-0.00001, length=nrep)
    
    Amat <- cbind(rep(1,5), Returnsmean[1:10], diag(1,10)) # we reconstruct A matrix

    for (i in 1:nrep) # compute efficient frontier
            {
              bvec <- c(1, muP[i],rep(0,10)) # constraint vector
              result <- solve.QP(Dmat=2*Returnscov[1:10,1:10], dvec=rep(0,10), Amat=Amat, bvec=bvec,
                                 meq=2)  
              # meq=2: all constraints so far are equality constraints
              sdP[i] <- sqrt(result$value)
              weights[i,] <- result$solution
            }
    
    MV <- (sdP == min(sdP)) 
    MVweights[a,] <- t(weights[MV,])
    
    sharpe <- (muP-mufree)/sdP 
    TAN <- (sharpe == max(sharpe))
    TANweights[a,] <- t(weights[TAN,])
  } else 
  {
    MVweights[a,] <- MVweights[a-1,]
    TANweights[a,] <- TANweights[a-1,]
  }
}
```

```{r,  include=FALSE}
#Next, we create a loop for the minimum variance portfolio. 
for (a in 2:(nrow(Returns.xts)-127))
{
  
   if (Returns[a+125,]$Friday==TRUE) # rebalance portfolio and calculate return
  {
     
    Returnscov <- cov(Returns.xts[a:(a+126),-1]) # remove end of the week column
    
        obj <- function(w) {
          
          if (sum(w)==0) {w <- w + 1e-2}
          
          w <- w/sum(w) #normalizing the weight vector
          
          out <- max(w*(Returnscov%*%w))
          return(out)
        }

    out <- DEoptim(fn=obj, lower=rep(0,10),upper=rep(1,10),DEoptim.control(itermax=itermax,trace=F))
    wMinContr <- out$optim$bestmem/sum(out$optim$bestmem)
     
    MINCweights[a,] <- wMinContr

   } else 
  {
    MINCweights[a,] <- MINCweights[a-1,]
  }
}
```

```{r,  include=FALSE}
#Compare the three portfolios by reporting the following statistics of their weekly ex-post returns:
Returnstest <- as.matrix(as.data.frame(t(Returns[127:nrow(Returns),-1])))
colnames(Returnstest) <- seq(1,ncol(Returnstest),by=1)

MVweights <- as.matrix(as.data.frame(MVweights))
rownames(MVweights) <- seq(1,ncol(Returnstest),by=1)

TANweights <- as.matrix(as.data.frame(TANweights))
rownames(TANweights) <- seq(1,ncol(Returnstest),by=1)

MINCweights <- as.matrix(as.data.frame(MINCweights))
rownames(MINCweights) <- seq(1,ncol(Returnstest),by=1)

MVreturns   <- as.data.frame((MVweights%*%Returnstest)[1,])/100
TANreturns  <- as.data.frame((TANweights%*%Returnstest)[1,])/100
MINCreturns <- as.data.frame((MINCweights%*%Returnstest)[1,])/100
```

```{r,  include=FALSE}
### the sample mean of ex-post returns
MVmean<- apply(MVreturns,2,mean)
TANmean<- apply(TANreturns,2,mean)
MINCmean<- apply(MINCreturns,2,mean)
MVmean
TANmean
MINCmean
#Returnsqn <- apply(Returns.xts,2,qn)
```

```{r,  include=FALSE}
### the sample standard deviation of ex-post returns
MVsd<- apply(MVreturns,2,sd)
TANsd<- apply(TANreturns,2,sd)
MINCsd<- apply(MINCreturns,2,sd)
MVsd
TANsd
MINCsd
```

```{r,  include=FALSE}
###  the information ratio IR = mean/std
MVir <- MVmean/MVsd
TANir <- TANmean/TANsd
MINCir <- MINCmean/MINCsd
MVir
TANir
MINCir
```

```{r,  include=FALSE}
###  the 5% and 1% Value-at-Risk: the loss at the (empirical) 5% and 1% quantile of the ex-post returns
MVvar5 <- quantile(MVreturns[,1],0.05)
TANvar5<- quantile(TANreturns[,1],0.05)
MINCvar5<- quantile(MINCreturns[,1],0.05)
MVvar5
TANvar5
MINCvar5

MVvar1<- quantile(MVreturns[,1],0.01)
TANvar1<- quantile(TANreturns[,1],0.01)
MINCvar1<- quantile(MINCreturns[,1],0.01)
MVvar1
TANvar1
MINCvar1
```

```{r,  include=FALSE}
#make xts object of returns and plus one
MVreturns   <- xts((1+(MVreturns)),order.by = index(completedata[127:nrow(completedata)]))
TANreturns  <- xts((1+(TANreturns)),order.by = index(completedata[127:nrow(completedata)]))
MINCreturns <- xts((1+(MINCreturns)),order.by = index(completedata[127:nrow(completedata)]))
```

```{r,  include=FALSE}
# Cumulative returns
MVcumreturns   <- MVreturns
TANcumreturns  <- TANreturns
MINCcumreturns <- MINCreturns

for (i in 2:nrow(MVreturns))
{
  MVcumreturns[i,]    <- MVcumreturns[i-1,]%*%MVreturns[i,]
  TANcumreturns[i,]   <- TANcumreturns[i-1,]%*%TANreturns[i,]
  MINCcumreturns[i,]  <- MINCcumreturns[i-1,]%*%MINCreturns[i,]
}
```

Starting with an inital wealth of USD 1000 we plot the evolution of the portfolio returns over time. If one would invested USD 1000 in 1999 he would have around USD 5000 in 2016 when he invested in the minimum variance portfolio, USD 6500 when he invested the tangency portfolio and USD 8000 in the minimum contribution portfolio. 

```{r fig5, echo=FALSE, fig.cap="\\label{fig:fig5}Portfolio wealth evolution starting with an inital wealth of 1000$ with a rolling window with six months"}
# Plot ewealth evolution
PfReturns <- cbind(MVcumreturns,TANcumreturns,MINCcumreturns)*1000
PfReturns <- data.frame(date=index(PfReturns),coredata(PfReturns))
colnames(PfReturns) <- c("Date","MV","TAN","MIN CONTR")
PfReturns <- melt(PfReturns,id="Date")
colnames(msdmelt) <- c("MV","TAN","MIN CONTR")

p <- ggplot(PfReturns, aes(x = Date,y=value)) + geom_line(aes(color=variable)) 
p
```

```{r,  include=FALSE}
####  the asset turnover
MVat   <- MVreturns
TANat  <- TANreturns
MINCat <- MINCreturns

for (i in 2:nrow(MVweights))
{
  MVat[i,] <- sum(abs(MVweights[i,]-MVweights[i-1,]))
  TANat[i,] <- sum(abs(TANweights[i,]-TANweights[i-1,]))
  MINCat[i,] <- sum(abs(MINCweights[i,]-MINCweights[i-1,]))
}

MVat <- subset(MVat, MVat[,1] > 0)
TANat <- subset(TANat, TANat[,1] > 0)
MINCat <- subset(MINCat, MINCat[,1] > 0)

MVat <- mean(MVat[,1])
TANat <- mean(TANat[,1])
MINCat <- mean(MINCat[,1])
```

```{r,  include=FALSE}
# Create table of statistics
dt <- data.frame(matrix(ncol = 3, nrow = 7))
colnames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
rownames(dt) <- c("Cumulative Return","Expected Return","Standard Deviation","Information Ratio","Value-at-Risk 5%","Value-at-Risk 1%","Asset Turnover")
dt[1,] <- c(MVcumreturns[nrow(MVcumreturns),],TANcumreturns[nrow(MVcumreturns),],MINCcumreturns[nrow(MVcumreturns),])
dt[2,] <- c(MVmean,TANmean,MINCmean)
dt[3,] <- c(MVsd,TANsd,MINCsd)
dt[4,] <- c(MVir,TANir,MINCir)
dt[5,] <- c(MVvar5,TANvar5,MINCvar5)
dt[6,] <- c(MVvar1,TANvar1,MINCvar1)
dt[7,]<- c(MVat,TANat,MINCat)
```

In Table 5 the summary statistics are shown. We can draw the following conclusions on these statistics. The expected return of the tangecy portfolio is the highest. Next, the standard deviation of the minimum variance portfolio is the lowest as expected. The information ratio (IR) measures the expected return per unit of risk. In this case the risk is measured as the standard deviation $\sigma$. The minimum variance earned an average return of 4.7% per unit of standard deviation $\sigma$. 

The Value-at-Risk (VaR) indicators of 1% and 5% show that tangency portfolio is the most risky. We can interprete this as follows. For the minimum variance portfolio the likelihood of having a daily return lower as -1.18% and -2.55% is respecitively 5% and 1%. Notice, this risk indicator is based on historical data.

Finally, the portfolio turnover measures how frequently assets within a portfolio are bought and sold. Table 5 shows that the tangency portfolio is the most active portfolio as it has the highest asset turnover. On the other hand, the minimum variance portfolio has bought and sold the least assets. Notice, for an individual investor this can be really important statistic as transactions costs can have a big impact on the net portolio return. 

```{r, echo=FALSE}
kable(dt, format = "latex", caption = "Summary Statistics Portfolios (rebalancing with six months)", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

## Rolling window with three months

```{r,  include=FALSE}
# Rolling window with three months
# We do exactly the same expect 63 observations are taken into account 
# Reload data
completedata <- data_backup
data <- data[1:63,]
Returns.xts <- xts(data*100,order.by = index(data)) # multiply by 100 !!
```

```{r,  include=FALSE}
# By the numbers
Returnsmean <- apply(Returns.xts,2,mean)
Returnssd <- apply(Returns.xts,2,sd)
Returnsmedian <- apply(Returns.xts,2,mean)
Returnsqn <- apply(Returns.xts,2,qn) #trade off efficiency and robustness 
```

```{r,  include=FALSE}
Returns <- as.data.frame(data)
Returns$Year <- year(index(data))
Returns$Month <- month(index(data))
Returns <- cbind(row.names(as.data.frame(data)),Returns)
colnames(Returns)<-c("Date",colnames(data),"Year","Month")

Monthlysd <- ddply(Returns,.(Year,Month),colwise(sd))
Monthlysd$Date <- strptime(sprintf("%s-%02d-01",Monthlysd$Year,Monthlysd$Month),"%Y-%m-%d")
msdmelt <- melt(Monthlysd[,-(1:2)],id="Date")
colnames(msdmelt)[2:3] <- c("Equity","std_Return")
ggplot(msdmelt) + geom_line(aes_string(x="Date",y="std_Return",color="Equity"),size=1.5) + ggtitle("Monthly Rolling Standard Deviations of Daily Returns of 10 shares") + theme(panel.background = element_rect(fill="#CCCCEE"), legend.key = element_rect(fill="#CCCCEE"))
```

```{r,  include=FALSE}
# Estimate covariance matrix
Returnscov <- cov(Returns.xts)
```


```{r, include=FALSE}
kable(round(Returnscov,2), format = "latex", caption = "Coviarance Matrix", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```


```{r ,error=TRUE, include=FALSE}
# No short selling - we add an extra constraint e.g. mutual funds 
Amat <- cbind(rep(1,5), Returnsmean[1:10], diag(1,10),diag(-1,10)) # we reconstruct A matrix

N <- length(Returnsmean) 
Amat <- cbind(rep(1,N), Returnsmean, diag(1,nrow=N), diag(-1,nrow=N)) 

# closure constraint
# diag(1,6) 
nrep <- 1000 # we make 1000 replications
muP <- seq(0.001, 0.06, length=nrep) # nrep targets is a sequence from 0,1% to 6% in 1000 steps
sdP <- rep(0, nrep) # 1000 empty to save standard deviation
weights <- matrix(0, nrow=nrep, ncol=10) # 1000 empty matrices were we will save the weights. 

for (i in 1:nrep)
{
  bvec <- c(1, muP[i], rep(0,N), rep(-1,N)) # constraint vector
  result <- solve.QP(Dmat=2*Returnscov, dvec=rep(0,10), Amat=Amat, bvec=bvec,
                     meq=2)  
  # meq=2: all constraints so far are equality constraints
  sdP[i] <- sqrt(result$value)
  weights[i,] <- result$solution
}
# Crashes, why? 
# Because no short selling constraint limits feasible return within range of indivdual equity returns 
# The return cannot be achieved 
```

```{r,  include=FALSE}
# This will work: because we adjust the returns 
muP <- seq(min(Returnsmean)+0.00001, max(Returnsmean)-0.00001, length=nrep)
sdP <- rep(0, nrep) # 1000 empty to save standard deviation
weights <- matrix(0, nrow=nrep, ncol=10) # 1000 empty matrices were we will save the weights. 

for (i in 1:nrep)
{
  bvec <- c(1, muP[i],rep(0,10), rep(-1,N))  # constraint vector
  result <- solve.QP(Dmat=2*Returnscov[1:10,1:10], dvec=rep(0,10), Amat=Amat, bvec=bvec,
                     meq=2)  
  # meq=2: all constraints so far are equality constraints
  sdP[i] <- sqrt(result$value)
  weights[i,] <- result$solution
}
```

```{r,  include=FALSE}
## Efificient frontier and Minimum Variance Portfolio

plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
# Minumum Variance portfolio
MV <- (sdP == min(sdP)) 
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
# Effective portfolios
EFF <- (muP > muP[MV])
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
weights[MV,]
```

```{r,  include=FALSE}
## Risk free portfolio

mufree <- 0.03 # input value of risk-free interest rate

plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
```

```{r,  include=FALSE}
## Tangency Portfolio
sharpe <- (muP-mufree)/sdP 
TAN <- (sharpe == max(sharpe)) 
weights[TAN,] 
sdpT <- sdP[TAN]
mupT <- muP[TAN]
```

```{r,  include=FALSE}
plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
points(sdP[TAN], muP[TAN], cex=2, pch=16,col='blue') 
lines(c(0,5), mufree+c(0,5)*(muP[TAN]-mufree)/sdP[TAN], lwd=4, lty=1,
      col="blue") 
for (i in 1:ncol(data))
{
  text(Returnssd[i], Returnsmean[i], colnames(data[,i]), cex=1)
}
```

```{r,  include=FALSE}
## Minimum risk contribution portfolio
library(DEoptim)

obj <- function(w) {
      
      if (sum(w)==0) {w <- w + 1e-2}
      
      w <- w/sum(w) #normalizing the weight vector
      
      out <- max(w*(Returnscov%*%w))
      return(out)
}
```


```{r, results="hide", include=FALSE}
itermax = 100
out <- DEoptim(fn=obj, lower=rep(0,10),upper=rep(1,10),DEoptim.control(itermax=itermax,trace=F))
wMinContr <- out$optim$bestmem/sum(out$optim$bestmem)
```

```{r,  include=FALSE}
muPMRC <- wMinContr%*%Returnsmean
sdPMRC <- sqrt(wMinContr%*%Returnscov%*%wMinContr)
```

```{r fig, include=FALSE, fig.cap="\\label{fig:fig} Effcient frontier (red), line (blue) connecting the risk-free asset and tangency portfolio (blue dot), the minimum variance portfolio (red triangle), the minimum risk contribution portfolio (green symbol) and 10 individual stocks"}
plot(sdP, muP, type="l", xlim=c(0,6), ylim=c(-0.4,0.4), lty=3)
points(sdP[MV], muP[MV], cex=2, pch=17, col='red') 
lines(sdP[EFF], muP[EFF], type="l", xlim=c(0,5), ylim=c(0,0.3),
      lwd=3, col="red") 
points(0, mufree, cex=2, pch=15) 
points(sdP[TAN], muP[TAN], cex=2, pch=16,col='blue') 
points(sdPMRC, muPMRC, cex=3, pch=18,col='green') 
lines(c(0,5), mufree+c(0,5)*(muP[TAN]-mufree)/sdP[TAN], lwd=4, lty=1,
      col="blue") 
for (i in 1:ncol(data))
{
  text(Returnssd[i], Returnsmean[i], colnames(data[,i]), cex=1)
}
```


```{r,  include=FALSE}
dt <- data.frame(matrix(ncol = 3, nrow = 3))
colnames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
rownames(dt) <- c("Expected Return","Standard Deviation","Sharpe Ratio")
MVsharpe <- (muP[MV]-0.03)/sdP[MV]
TANsharpe <- (muP[TAN]-0.03)/sdP[TAN]
MINCsharpe <- (muPMRC-0.03)/sdPMRC
dt[1,] <- c(muP[MV],muP[TAN],muPMRC)
dt[2,] <- c(sdP[MV],sdP[TAN],sdPMRC)
dt[3,] <- c(MVsharpe,TANsharpe,MINCsharpe)
```


```{r, include=FALSE}
kable(dt, format = "latex", caption = "Summary Statistics Portfolios", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

```{r,  include=FALSE}
dt <- data.frame(matrix(ncol = 10, nrow = 3))
rownames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
colnames(dt) <- c("HON","SUN","STW","DRH","AVI","CBL","MER","GPS","MAS","BLC")
dt[1,] <- round(weights[MV,],2)
dt[2,] <- round(weights[TAN,],2)
dt[3,] <- round(wMinContr,2)
```


```{r, include=FALSE}
kable(dt, format = "latex", caption = "Portfolios Weights", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

```{r,  include=FALSE}
Returns.xts <- xts(completedata*100,order.by = index(completedata)) # multiply by 100 !!
```


```{r,  include=FALSE}
Returns.xts <- cbind(.indexwday(Returns.xts),Returns.xts)

for (i in 1:(nrow(Returns.xts)-1)) # loop over daily returns
  { 
      if (Returns.xts[i,1]==4 && Returns.xts[i+1,1]==1) # if after thursday monday thursday ad end of the week
      { 
        Returns.xts[i,1]<-5
      } else {}
     
  }

Returns.xts[,1][!Returns.xts[,1]==5] <- FALSE # all weekdays which are not friday are zero
Returns.xts[,1][Returns.xts[,1]==5] <- TRUE # all weekdays which are friday or thursday last day week are one

colnames(Returns.xts) <- c("Friday",colnames(Returns.xts[,-1]))
Returns <- as.data.frame(Returns.xts)
```

```{r,  include=FALSE}
#Create empty dataframes for returns and weights of different time periodes. 
MVweights   <-  matrix(0,nrow = nrow(Returns)-63,ncol=ncol(Returns)-1)
TANweights  <-  matrix(0,nrow = nrow(Returns)-63,ncol=ncol(Returns)-1)
MINCweights <-  matrix(0,nrow = nrow(Returns)-63,ncol=ncol(Returns)-1)
MVweights[1,]   <- weights[MV,]
TANweights[1,]  <- weights[TAN,]
MINCweights[1,] <- wMinContr
```

```{r,  include=FALSE}
#### MV and TAN portfolio
for (a in 2:(nrow(Returns.xts)-65))
{
  
  if (Returns[a+63,]$Friday==TRUE) # rebalance portfolio and calculate return
  {
    Returnscov <- cov(Returns.xts[a:(a+63),-1])
    Returnsmean <- apply(Returns.xts[a:(a+63),-1],2,mean)
    muP <- seq(min(Returnsmean)+.00001, max(Returnsmean)-0.00001, length=nrep)
    
    Amat <- cbind(rep(1,5), Returnsmean[1:10], diag(1,10)) # we reconstruct A matrix

    for (i in 1:nrep) # compute efficient frontier
            {
              bvec <- c(1, muP[i],rep(0,10)) # constraint vector
              result <- solve.QP(Dmat=2*Returnscov[1:10,1:10], dvec=rep(0,10), Amat=Amat, bvec=bvec,
                                 meq=2)  
              # meq=2: all constraints so far are equality constraints
              sdP[i] <- sqrt(result$value)
              weights[i,] <- result$solution
            }
    
    MV <- (sdP == min(sdP)) 
    MVweights[a,] <- t(weights[MV,])
    
    sharpe <- (muP-mufree)/sdP 
    TAN <- (sharpe == max(sharpe))
    TANweights[a,] <- t(weights[TAN,])
  } else 
  {
    MVweights[a,] <- MVweights[a-1,]
    TANweights[a,] <- TANweights[a-1,]
  }
}
```

```{r,  include=FALSE}
#Next, we create a loop for the minimum variance portfolio. 
for (a in 2:(nrow(Returns.xts)-65))
{
  
   if (Returns[a+63,]$Friday==TRUE) # rebalance portfolio and calculate return
  {
     
    Returnscov <- cov(Returns.xts[a:(a+63),-1]) # remove end of the week column
    
        obj <- function(w) {
          
          if (sum(w)==0) {w <- w + 1e-2}
          
          w <- w/sum(w) #normalizing the weight vector
          
          out <- max(w*(Returnscov%*%w))
          return(out)
        }

    out <- DEoptim(fn=obj, lower=rep(0,10),upper=rep(1,10),DEoptim.control(itermax=itermax,trace=F))
    wMinContr <- out$optim$bestmem/sum(out$optim$bestmem)
     
    MINCweights[a,] <- wMinContr

   } else 
  {
    MINCweights[a,] <- MINCweights[a-1,]
  }
}
```

```{r,  include=FALSE}
#Compare the three portfolios by reporting the following statistics of their weekly ex-post returns:
Returnstest <- as.matrix(as.data.frame(t(Returns[64:nrow(Returns),-1])))
colnames(Returnstest) <- seq(1,ncol(Returnstest),by=1)

MVweights <- as.matrix(as.data.frame(MVweights))
rownames(MVweights) <- seq(1,ncol(Returnstest),by=1)

TANweights <- as.matrix(as.data.frame(TANweights))
rownames(TANweights) <- seq(1,ncol(Returnstest),by=1)

MINCweights <- as.matrix(as.data.frame(MINCweights))
rownames(MINCweights) <- seq(1,ncol(Returnstest),by=1)

MVreturns   <- as.data.frame((MVweights%*%Returnstest)[1,])/100
TANreturns  <- as.data.frame((TANweights%*%Returnstest)[1,])/100
MINCreturns <- as.data.frame((MINCweights%*%Returnstest)[1,])/100
```

```{r,  include=FALSE}
### the sample mean of ex-post returns
MVmean<- apply(MVreturns,2,mean)
TANmean<- apply(TANreturns,2,mean)
MINCmean<- apply(MINCreturns,2,mean)
MVmean
TANmean
MINCmean
#Returnsqn <- apply(Returns.xts,2,qn)
```

```{r,  include=FALSE}
### the sample standard deviation of ex-post returns
MVsd<- apply(MVreturns,2,sd)
TANsd<- apply(TANreturns,2,sd)
MINCsd<- apply(MINCreturns,2,sd)
MVsd
TANsd
MINCsd
```

```{r,  include=FALSE}
###  the information ratio IR = mean/std

MVir <- MVmean/MVsd
TANir <- TANmean/TANsd
MINCir <- MINCmean/MINCsd
MVir
TANir
MINCir
```

```{r,  include=FALSE}
###  the 5% and 1% Value-at-Risk: the loss at the (empirical) 5% and 1% quantile of the ex-post returns
MVvar5 <- quantile(MVreturns[,1],0.05)
TANvar5<- quantile(TANreturns[,1],0.05)
MINCvar5<- quantile(MINCreturns[,1],0.05)
MVvar5
TANvar5
MINCvar5

MVvar1<- quantile(MVreturns[,1],0.01)
TANvar1<- quantile(TANreturns[,1],0.01)
MINCvar1<- quantile(MINCreturns[,1],0.01)
MVvar1
TANvar1
MINCvar1
```

```{r,  include=FALSE}
#make xts object of returns and plus one
MVreturns   <- xts((1+(MVreturns)),order.by = index(completedata[64:nrow(completedata)]))
TANreturns  <- xts((1+(TANreturns)),order.by = index(completedata[64:nrow(completedata)]))
MINCreturns <- xts((1+(MINCreturns)),order.by = index(completedata[64:nrow(completedata)]))
```

```{r,  include=FALSE}
MVcumreturns   <- MVreturns
TANcumreturns  <- TANreturns
MINCcumreturns <- MINCreturns

for (i in 2:nrow(MVreturns))
{
  MVcumreturns[i,]    <- MVcumreturns[i-1,]%*%MVreturns[i,]
  TANcumreturns[i,]   <- TANcumreturns[i-1,]%*%TANreturns[i,]
  MINCcumreturns[i,]  <- MINCcumreturns[i-1,]%*%MINCreturns[i,]
}
```

Finally, we repeat the same exercise with a rolling window of three months (63 days instead 126). The minimum variance and minimum contribution portfolio end up with higher cumulative returns as with a rolling window of six months. This could be explained by the fact that rebalancing each three months allows for more flexibility. Therefore, these portfolios takes more recent data into account. 

The fact that the cumulative of the tangency portfolio is lower as the minimum variance portfolio could be counter-intuitive. Notice, the minimum variance solution is constructed with stocks that have low variances and co-variances. Theoretically, we would expect that this should have a low expected return profile in the long run. However, in contradiction to modern portfolio theory it turns out that stocks that have low-volatility or low-beta experience higher returns than high-volatility or high-beta stocks. This is well-documented in the current literature as the low-volatility anomaly. This explains the fact that we end up with a higher cumulative return for the minimum variance portfolio compared to the tangency portfolio. 

```{r fig10, echo=FALSE, fig.cap="\\label{fig:fig10}Portfolio wealth evolution starting with an inital wealth of 1000$ with a rolling window with three months"}
PfReturns <- cbind(MVcumreturns,TANcumreturns,MINCcumreturns)*1000
PfReturns <- data.frame(date=index(PfReturns),coredata(PfReturns))
colnames(PfReturns) <- c("Date","MV","TAN","MIN CONTR")
PfReturns <- melt(PfReturns,id="Date")
colnames(msdmelt) <- c("MV","TAN","MIN CONTR")

p <- ggplot(PfReturns, aes(x = Date,y=value)) + geom_line(aes(color=variable)) 
p
```

Table 6 gives an overview of the summary statistics of the different portfolios. The cumulative returns of the minimum variance and minimum contribution portfolio is higher, while the cumulative return of the tangency portfolio is lower when we only use three months of data for rebalancing the weights. Notice, the value-at-risk indicator illustrates the tangency risk is more riskier. Finally, the asset turnover statistics are higher for all portfolios. 

```{r,  include=FALSE}
####  the asset turnover
MVat   <- MVreturns
TANat  <- TANreturns
MINCat <- MINCreturns

for (i in 2:nrow(MVweights))
{
  MVat[i,] <- sum(abs(MVweights[i,]-MVweights[i-1,]))
  TANat[i,] <- sum(abs(TANweights[i,]-TANweights[i-1,]))
  MINCat[i,] <- sum(abs(MINCweights[i,]-MINCweights[i-1,]))
}

MVat <- subset(MVat, MVat[,1] > 0)
TANat <- subset(TANat, TANat[,1] > 0)
MINCat <- subset(MINCat, MINCat[,1] > 0)

MVat <- mean(MVat[,1])
TANat <- mean(TANat[,1])
MINCat <- mean(MINCat[,1])
```

```{r,  include=FALSE}
dt <- data.frame(matrix(ncol = 3, nrow = 7))
colnames(dt) <- c("Minimum Variance","Tangency","Minimum Contribution")
rownames(dt) <- c("Cumulative Return","Expected Return","Standard Deviation","Information Ratio","Value-at-Risk 5%","Value-at-Risk 1%","Asset Turnover")
dt[1,] <- c(MVcumreturns[nrow(MVcumreturns),],TANcumreturns[nrow(MVcumreturns),],MINCcumreturns[nrow(MVcumreturns),])
dt[2,] <- c(MVmean,TANmean,MINCmean)
dt[3,] <- c(MVsd,TANsd,MINCsd)
dt[4,] <- c(MVir,TANir,MINCir)
dt[5,] <- c(MVvar5,TANvar5,MINCvar5)
dt[6,] <- c(MVvar1,TANvar1,MINCvar1)
dt[7,]<- c(MVat,TANat,MINCat)
```

```{r, echo=FALSE}
kable(dt, format = "latex", caption = "Summary Statistics Portfolios (rebalancing with three months)", booktabs = T) %>% kable_styling(latex_options = c("striped", "hold_position"))
```

